par(mfcol = c(1,1))
library("igraph")
#Ищем минимальный срез графа
#Сначала упрощаем граф
#проверки
checks <- function(g){
  if (is.matrix(g) == FALSE) {
    stop("g не является матрицей")
  }
  if (is.numeric(g) == FALSE) {
    stop("В матрице g не все элементы являются числами")
  }
  if (sum(is.na(g)) != 0) {
    stop("В матрице g содержатся пропущенные значения")
  }
  if (nrow(g) != ncol(g)) {
    stop("Матрица g не является квадратной")
  }
}
#Сначала упрощаем граф
simplification <- function(g){
  n <- nrow(g)
  #Убираем петли
  for (i in 1:n){
    g[i, i] <- 0
  }
  #Убираем веса
  g[g != Inf & g != 0] <- 1
  g[g == Inf] <- 0
  #Делаем граф неориентированным
  for (i in 1:n){
    for (j in 1:n){
      if(g[i, j] == 1){
        g[j, i] <- 1
      }
    }
  }
  return(g)
}
#Выбираем рёбро между вершинами (случайно)
choose_edge <- function(g){
  #Число ребёр
  n_edges <- sum(g)/2
  #Случайное ребро (его номер)
  x <- sample(1:n_edges, size = 1)
  n <- nrow(g)
  #переменная счетчик
  s <- 0
  #Перебираем имеющиеся ребра до тех пор, пока не дойдём до искомого
  #Как только найдём - возвращаем соответствующие ему вершины
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n){
      s <- s + g[i, j]
      if (s >= x){
        return(c(i, j))
      }
    }
  }
}
#Сжимаем граф
contract <- function(g, i, j){
  #Первая вершина должна быть "меньше" второй
  if (i > j) {
    s <- i
    i <- j
    j <- s
  }
  #ребра, соединяющие  вторую вершину с другими вершинами
  #теперь соединяют эти вершины с первой вершиной
  g[i, ] <- g[i, ] + g[j, ]
  g[ ,i] <- g[, i] + g[, j]
  #вторая вершина изолируется
  g[j, ] <- 0
  g[, j] <- 0
  #убираем петли
  g[i, i] <- 0
  return(g)
}
#Считаем количество неизолированных вершин
uninsulated <- function(g){
  n <- nrow(g)
  #счетчик для подсчета неизолированнных ершин
  k <- 0
  for (i in 1:n){
    if (sum(g[i, ]) != 0){
      k <- k + 1
    }
  }
  return(k)
}
#Ищем сам срез
cut <- function(g){
  #упрощаем граф
  g <- simplification(g)
  #пока не останется меньше двух неизолированных вершины (!!!)
  while (uninsulated(g) > 2){
    #выбираем случайное ребро
    m <- choose_edge(g)
    #смотрим на соответствующие ему вершины
    a <- m[1]
    b <- m[2]
    #изолируем вершину с большим номером
    #при этом ребра, соединяющие вершину с большим номером с другими вершинами
    #теперь ведут в вершину с меньшим номером
    g <- contract(g, a, b)
  }
  #возвращаем количество оставшихся ребер
  return(sum(g)/2)
}
#Ищем минимальный срез
min_cut <- function(g){
  #проверки
  checks(g)
  #текущий минимум
  g_min <- Inf
  #количество повторений алгоритма
  N <- 2^nrow(g)
  #дальше просто ищем минимум
  for (i in (1:N)){
    x <- cut(g)
    if (x < g_min){
      g_min <- x
    }
    #если найден срез в одно ребро, то прекращаем работу алгоритма
    if (g_min == 1){
      return(g_min)
    }
  }
  return(g_min)
}
#пример работы алгоритма для случайного графа 7 на 7
g1 <- matrix(sample(x = c(1:9, Inf), size = 49, replace = T, prob = c(rep(0.6/9, 9), 0.4)),
            nrow = 7, ncol = 7)
#так выглядит граф после упрощения (необязательная отрисовка)
g2 <- simplification(g1)
G <- graph.adjacency(g2, mode = "undirected")
plot.igraph(G)
#находим минимальный срез
min_cut(g1)